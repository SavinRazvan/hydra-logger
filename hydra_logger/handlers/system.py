"""
System Handlers for Hydra-Logger

This module provides system-level logging handlers for various operating
systems and logging infrastructures. It includes integration with system
logging services and event logs.

ARCHITECTURE:
- SyslogHandler: Unix/Linux syslog integration
- SystemdJournalHandler: Linux systemd journal integration
- WindowsEventLogHandler: Windows Event Log integration
- SystemHandlerFactory: Factory for creating system handlers

SUPPORTED SYSTEMS:
- Unix/Linux: Syslog protocol (RFC 3164)
- Linux: Systemd journal integration
- Windows: Windows Event Log integration

SYSLOG FEATURES:
- RFC 3164 compliant syslog protocol
- Multiple facilities (KERN, USER, MAIL, DAEMON, etc.)
- Severity levels (EMERGENCY, ALERT, CRITICAL, ERROR, WARNING, NOTICE, INFO, DEBUG)
- UDP and TCP transport support
- Configurable hostname and application name

SYSTEMD JOURNAL FEATURES:
- Native systemd journal integration
- Structured logging with fields
- Automatic metadata extraction
- Fallback to syslog when unavailable

WINDOWS EVENT LOG FEATURES:
- Windows Event Log integration
- Event types (Information, Warning, Error, Critical)
- Application-specific event sources
- Structured event data

USAGE EXAMPLES:

Syslog Handler:
    from hydra_logger.handlers import SyslogHandler
    from hydra_logger.handlers.system import SyslogFacility, SyslogSeverity
    
    handler = SyslogHandler(
        facility=SyslogFacility.USER,
        host="localhost",
        port=514,
        app_name="my-app"
    )
    logger.addHandler(handler)

Systemd Journal Handler:
    from hydra_logger.handlers import SystemdJournalHandler
    
    handler = SystemdJournalHandler(
        identifier="my-app",
        facility="user"
    )
    logger.addHandler(handler)

Windows Event Log Handler:
    from hydra_logger.handlers import WindowsEventLogHandler
    
    handler = WindowsEventLogHandler(
        app_name="MyApp",
        event_source="MyApp",
        log_name="Application"
    )
    logger.addHandler(handler)

Factory Pattern:
    from hydra_logger.handlers import SystemHandlerFactory
    
    # Create syslog handler
    handler = SystemHandlerFactory.create_handler(
        "syslog",
        facility=SyslogFacility.USER,
        host="localhost"
    )
    
    # Create systemd handler
    handler = SystemHandlerFactory.create_handler(
        "systemd",
        identifier="my-app"
    )
    
    # Create Windows Event Log handler
    handler = SystemHandlerFactory.create_handler(
        "windows_event_log",
        app_name="MyApp"
    )

Auto-Detection:
    # Automatically detect and create appropriate handler
    handler = SystemHandlerFactory.create_auto_handler()
    logger.addHandler(handler)

Performance Monitoring:
    # Get system handler statistics
    stats = handler.get_syslog_stats()  # or get_journal_stats() or get_windows_event_log_stats()
    print(f"Messages sent: {stats['messages_sent']}")
    print(f"Error count: {stats['error_count']}")

CONFIGURATION:
- Syslog: facility, host, port, socktype, app_name, include_priority, include_timestamp
- Systemd: identifier, facility, structured logging
- Windows: app_name, event_source, log_name, event types

ERROR HANDLING:
- Graceful fallback mechanisms
- Connection recovery and retry
- Comprehensive error logging
- System-specific error handling
- Graceful degradation

THREAD SAFETY:
- Thread-safe operations with proper locking
- Safe concurrent access
- Atomic operations where possible
- System-specific thread safety
"""

import socket
import platform
from typing import Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum
from .base import BaseHandler
from ..types.records import LogRecord
from ..types.levels import LogLevel

# Windows Event Log support - only available on Windows
WINDOWS_EVENT_LOG_AVAILABLE = False
win32evtlog = None
win32evtlogutil = None


if platform.system() == "Windows":
    try:
        import win32evtlog  # type: ignore
        import win32evtlogutil  # type: ignore
        WINDOWS_EVENT_LOG_AVAILABLE = True
    except ImportError:
        # Windows Event Log support not available
        WINDOWS_EVENT_LOG_AVAILABLE = False
        win32evtlog = None
        win32evtlogutil = None


class SyslogFacility(Enum):
    """Syslog facilities as defined in RFC 3164."""
    KERN = 0       # Kernel messages
    USER = 1       # User-level messages
    MAIL = 2       # Mail system
    DAEMON = 3     # System daemons
    AUTH = 4       # Security/authorization messages
    SYSLOG = 5     # Messages generated by syslogd
    LPR = 6        # Line printer subsystem
    NEWS = 7       # Network news subsystem
    UUCP = 8       # UUCP subsystem
    CRON = 9       # Cron daemon
    AUTHPRIV = 10  # Security/authorization messages (private)
    FTP = 11       # FTP daemon
    LOCAL0 = 16    # Local use 0
    LOCAL1 = 17    # Local use 1
    LOCAL2 = 18    # Local use 2
    LOCAL3 = 19    # Local use 3
    LOCAL4 = 20    # Local use 4
    LOCAL5 = 21    # Local use 5
    LOCAL6 = 22    # Local use 6
    LOCAL7 = 23    # Local use 7


class SyslogSeverity(Enum):
    """Syslog severity levels as defined in RFC 3164."""
    EMERGENCY = 0  # System is unusable
    ALERT = 1      # Action must be taken immediately
    CRITICAL = 2   # Critical conditions
    ERROR = 3      # Error conditions
    WARNING = 4    # Warning conditions
    NOTICE = 5     # Normal but significant condition
    INFO = 6       # Informational messages
    DEBUG = 7      # Debug-level messages


@dataclass
class SyslogConfig:
    """Configuration for syslog handler."""
    facility: SyslogFacility = SyslogFacility.USER
    host: str = "localhost"
    port: int = 514
    socktype: socket.SocketKind = socket.SOCK_DGRAM
    app_name: str = "hydra-logger"
    include_priority: bool = True
    include_timestamp: bool = True
    include_hostname: bool = True
    include_app_name: bool = True
    include_process_id: bool = True
    max_message_size: int = 1024
    timeout: float = 5.0


class SyslogHandler(BaseHandler):
    """Syslog handler for Unix/Linux systems."""

    def __init__(
        self,
        facility: SyslogFacility = SyslogFacility.USER,
        host: str = "localhost",
        port: int = 514,
        socktype: socket.SocketKind = socket.SOCK_DGRAM,
        app_name: str = "hydra-logger",
        timestamp_config=None,
        **kwargs
    ):
        """
        Initialize syslog handler.

        Args:
            facility: Syslog facility
            host: Syslog host
            port: Syslog port
            socktype: Socket type
            app_name: Application name
            **kwargs: Additional arguments
        """
        super().__init__(name="syslog", level=LogLevel.NOTSET, timestamp_config=timestamp_config)
        self._facility = facility
        self._host = host
        self._port = port
        self._socktype = socktype
        self._app_name = app_name
        self._socket = None
        
        # Formatter-aware handling attributes
        self._is_csv_formatter = False
        self._is_json_formatter = False
        self._is_streaming_formatter = False
        self._needs_special_handling = False

    def setFormatter(self, formatter):
        """
        Set formatter and detect if it needs special handling.
        
        Args:
            formatter: Formatter instance
        """
        super().setFormatter(formatter)
        if formatter:
            self._is_csv_formatter = (hasattr(formatter, 'format_headers') and hasattr(formatter, 'should_write_headers'))
            self._is_json_formatter = hasattr(formatter, 'write_header')
            self._is_streaming_formatter = hasattr(formatter, 'format_for_streaming')
            self._needs_special_handling = (self._is_csv_formatter or self._is_json_formatter or self._is_streaming_formatter)
        else:
            self._is_csv_formatter = False
            self._is_json_formatter = False
            self._is_streaming_formatter = False
            self._needs_special_handling = False

    def _create_socket(self) -> None:
        """Create syslog socket."""
        try:
            self._socket = socket.socket(socket.AF_INET, self._socktype)
            self._socket.settimeout(5.0)
        except Exception:
            self._socket = None

    def _get_syslog_priority(self, level: int) -> int:
        """
        Convert log level to syslog priority.

        Args:
            level: Log level

        Returns:
            Syslog priority value
        """
        if level >= LogLevel.CRITICAL:
            return SyslogSeverity.CRITICAL.value
        elif level >= LogLevel.ERROR:
            return SyslogSeverity.ERROR.value
        elif level >= LogLevel.WARNING:
            return SyslogSeverity.WARNING.value
        elif level >= LogLevel.INFO:
            return SyslogSeverity.INFO.value
        else:
            return SyslogSeverity.DEBUG.value

    def _format_syslog_message(self, record: LogRecord) -> str:
        """
        Format log record for syslog.

        Args:
            record: Log record

        Returns:
            Formatted syslog message
        """
        priority = self._get_syslog_priority(record.level)
        facility = self._facility.value
        priority_value = facility * 8 + priority

        # Build message components
        parts = [f"<{priority_value}>"]

        if hasattr(record, 'timestamp'):
            parts.append(self.format_timestamp(record))

        if platform.node():
            parts.append(platform.node())

        parts.append(self._app_name)

        if hasattr(record, 'process_id'):
            parts.append(f"[{record.process_id}]")

        parts.append(":")

        if self.formatter:
            message = self.formatter.format(record)
        else:
            message = f"{record.level_name}: {record.message}"

        parts.append(message)

        return " ".join(parts)

    def emit(self, record: LogRecord) -> None:
        """
        Emit log record to syslog.

        Args:
            record: Log record to emit
        """
        try:
            if not self._socket:
                self._create_socket()

            if self._socket:
                message = self._format_syslog_message(record)
                message_bytes = message.encode('utf-8')

                if self._socktype == socket.SOCK_DGRAM:
                    self._socket.sendto(message_bytes, (self._host, self._port))
                else:
                    self._socket.connect((self._host, self._port))
                    self._socket.send(message_bytes)
        except Exception:
            # Silently ignore syslog errors
            pass

    def close(self) -> None:
        """Close the handler."""
        super().close()
        if self._socket:
            self._socket.close()
            self._socket = None

    def get_syslog_stats(self) -> Dict[str, Any]:
        """
        Get syslog statistics.

        Returns:
            Dictionary with syslog statistics
        """
        return {
            "facility": self._facility.value,
            "host": self._host,
            "port": self._port,
            "socket_type": "UDP" if self._socktype == socket.SOCK_DGRAM else "TCP",
            "app_name": self._app_name,
            "connected": self._socket is not None
        }


class SystemdJournalHandler(BaseHandler):
    """Systemd journal handler for Linux systems."""

    def __init__(
        self,
        identifier: str = "hydra-logger",
        facility: str = "user",
        **kwargs
    ):
        """
        Initialize systemd journal handler.

        Args:
            identifier: Journal identifier
            facility: Journal facility
            **kwargs: Additional arguments
        """
        super().__init__(name="systemd_journal", level=LogLevel.NOTSET)
        self._identifier = identifier
        self._facility = facility
        self._use_systemd = self._check_systemd_availability()

    def _check_systemd_availability(self) -> bool:
        """Check if systemd is available."""
        try:
            import subprocess
            result = subprocess.run(
                ["systemctl", "--version"],
                capture_output=True,
                timeout=1
            )
            return result.returncode == 0
        except Exception:
            return False

    def _get_journal_priority(self, level: int) -> str:
        """
        Convert log level to journal priority.

        Args:
            level: Log level

        Returns:
            Journal priority string
        """
        if level >= LogLevel.CRITICAL:
            return "emerg"
        elif level >= LogLevel.ERROR:
            return "err"
        elif level >= LogLevel.WARNING:
            return "warning"
        elif level >= LogLevel.INFO:
            return "info"
        else:
            return "debug"

    def emit(self, record: LogRecord) -> None:
        """
        Emit log record to systemd journal.

        Args:
            record: Log record to emit
        """
        if not self._use_systemd:
            # Fallback to syslog if systemd not available
            self._fallback_to_syslog(record)
            return

        try:
            priority = self._get_journal_priority(record.level)
            message = self.formatter.format(record) if self.formatter else str(record.message)

            fields = {
                "MESSAGE": message,
                "PRIORITY": priority,
                "SYSLOG_FACILITY": self._facility,
                "SYSLOG_IDENTIFIER": self._identifier
            }

            if hasattr(record, 'timestamp'):
                fields["TIMESTAMP"] = self.format_timestamp(record)

            if hasattr(record, 'process_id'):
                fields["SYSLOG_PID"] = str(record.process_id)

            self._send_to_journal(fields)
        except Exception:
            # Fallback to syslog on error
            self._fallback_to_syslog(record)

    def _send_to_journal(self, fields: Dict[str, str]) -> None:
        """
        Send message to systemd journal.

        Args:
            fields: Journal fields
        """
        try:
            import subprocess
            cmd = ["journalctl", "--no-pager", "-n", "1"]
            for key, value in fields.items():
                cmd.extend(["-t", f"{key}={value}"])
            subprocess.run(cmd, check=True)
        except Exception:
            # Silently ignore journal errors
            pass

    def _fallback_to_syslog(self, record: LogRecord) -> None:
        """
        Fallback to syslog if journal fails.

        Args:
            record: Log record
        """
        try:
            syslog_handler = SyslogHandler(
                facility=SyslogFacility.USER,
                app_name=self._identifier
            )
            syslog_handler.emit(record)
            syslog_handler.close()
        except Exception:
            # Silently ignore fallback errors
            pass

    def close(self) -> None:
        """Close the handler."""
        super().close()

    def get_journal_stats(self) -> Dict[str, Any]:
        """
        Get journal statistics.

        Returns:
            Dictionary with journal statistics
        """
        return {
            "identifier": self._identifier,
            "facility": self._facility,
            "systemd_available": self._use_systemd,
            "platform": platform.system()
        }


class WindowsEventLogHandler(BaseHandler):
    """Windows Event Log handler."""

    def __init__(
        self,
        app_name: str = "HydraLogger",
        event_source: str = "HydraLogger",
        log_name: str = "Application",
        **kwargs
    ):
        """
        Initialize Windows Event Log handler.

        Args:
            app_name: Application name
            event_source: Event source
            log_name: Log name
            **kwargs: Additional arguments
        """
        super().__init__(name="windows_event_log", level=LogLevel.NOTSET)
        self._app_name = app_name
        self._event_source = event_source
        self._log_name = log_name

        if not WINDOWS_EVENT_LOG_AVAILABLE:
            raise ImportError(
                "Windows Event Log support not available. "
                "This handler only works on Windows systems with pywin32 installed."
            )

        self._init_windows_event_log()

    def _init_windows_event_log(self) -> None:
        """Initialize Windows Event Log."""
        if not win32evtlogutil:
            raise ImportError("win32evtlogutil not available")
            
        try:
            # Try to register event source
            win32evtlogutil.AddSourceToRegistry(
                self._app_name,
                self._event_source,
                self._log_name
            )
        except Exception:
            # Source may already exist, continue
            pass

    def _get_event_type(self, level: int) -> int:
        """Convert log level to Windows event type."""
        if not win32evtlog:
            raise ImportError("win32evtlog not available")
            
        if level >= LogLevel.CRITICAL:
            return win32evtlog.EVENTLOG_ERROR_TYPE
        elif level >= LogLevel.ERROR:
            return win32evtlog.EVENTLOG_ERROR_TYPE
        elif level >= LogLevel.WARNING:
            return win32evtlog.EVENTLOG_WARNING_TYPE
        else:
            return win32evtlog.EVENTLOG_INFORMATION_TYPE

    def emit(self, record: LogRecord) -> None:
        """
        Emit log record to Windows Event Log.

        Args:
            record: Log record to emit
        """
        if not win32evtlogutil or not win32evtlog:
            return
            
        try:
            event_type = self._get_event_type(record.level)
            message = self.formatter.format(record) if self.formatter else str(record.message)

            # Prepare event data
            event_data = [
                f"Message: {message}",
                f"Level: {record.level_name}",
                f"Logger: {record.logger_name}"
            ]

            if hasattr(record, 'timestamp'):
                event_data.append(f"Timestamp: {self.format_timestamp(record)}")

            if hasattr(record, 'process_id'):
                event_data.append(f"Process ID: {record.process_id}")

            # Log to Windows Event Log
            win32evtlogutil.ReportEvent(
                self._event_source,
                event_type,
                0,  # Event category
                1000,  # Event ID
                event_data,
                None  # Raw data
            )
        except Exception:
            # Silently ignore event log errors
            pass

    def close(self) -> None:
        """Close the handler."""
        super().close()

    def get_windows_event_log_stats(self) -> Dict[str, Any]:
        """
        Get Windows Event Log statistics.

        Returns:
            Dictionary with event log statistics
        """
        return {
            "app_name": self._app_name,
            "event_source": self._event_source,
            "log_name": self._log_name,
            "platform": platform.system(),
            "windows_event_log_available": WINDOWS_EVENT_LOG_AVAILABLE
        }


class SystemHandlerFactory:
    """Factory for creating system handlers."""

    @staticmethod
    def create_handler(
        handler_type: str,
        **kwargs
    ) -> BaseHandler:
        """
        Create a system handler by type.

        Args:
            handler_type: Type of handler to create
            **kwargs: Handler-specific arguments

        Returns:
            Configured system handler
        """
        if handler_type.lower() == "syslog":
            return SyslogHandler(**kwargs)
        elif handler_type.lower() == "systemd":
            return SystemdJournalHandler(**kwargs)
        elif handler_type.lower() == "windows_event_log":
            return WindowsEventLogHandler(**kwargs)
        else:
            raise ValueError(f"Unknown system handler type: {handler_type}")

    @staticmethod
    def create_syslog_handler(**kwargs) -> SyslogHandler:
        """Create syslog handler."""
        return SyslogHandler(**kwargs)

    @staticmethod
    def create_systemd_handler(**kwargs) -> SystemdJournalHandler:
        """Create systemd journal handler."""
        return SystemdJournalHandler(**kwargs)

    @staticmethod
    def create_windows_event_log_handler(**kwargs) -> WindowsEventLogHandler:
        """Create Windows Event Log handler."""
        return WindowsEventLogHandler(**kwargs)

    @staticmethod
    def create_auto_handler(**kwargs) -> BaseHandler:
        """Create handler based on platform."""
        if platform.system() == "Windows":
            return WindowsEventLogHandler(**kwargs)
        elif platform.system() == "Linux":
            return SystemdJournalHandler(**kwargs)
        else:
            return SyslogHandler(**kwargs)
